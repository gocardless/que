#!/usr/bin/env ruby

require 'que'
require 'optparse'
require 'ostruct'
require 'logger'

class QueJobTimeoutError < StandardError; end

$stdout.sync = true

options = OpenStruct.new

OptionParser.new do |opts|
  opts.banner = 'usage: que [options] file/to/require ...'

  opts.on('-i', '--wake-interval [INTERVAL]', Float, "Set maximum interval between polls of the job queue (in seconds) (default: 0.1)") do |wake_interval|
    options.wake_interval = wake_interval
  end

  opts.on('-p', '--metrics-port [PORT]', Integer, "Enable metrics and expose them on this port") do |metrics_port|
    options.metrics_port = metrics_port
  end

  opts.on('-e', '--cursor-expiry [EXPIRY]', Integer, "Enable performance patch with cached cursors") do |cursor_expiry|
    options.cursor_expiry = cursor_expiry
  end

  opts.on('-m', '--metrics-labels [LABELS]', String, "Base labels for each prometheus metric, in key=value,... form") do |metrics_labels|
    options.metrics_labels = metrics_labels.split(",").each_with_object({}) do |kv, labels|
      key, value = kv.split("=")
      labels[key.to_sym] = value
    end
  end

  opts.on('-l', '--log-level [LEVEL]', String, "Set level of Que's logger (debug, info, warn, error, fatal) (default: info)") do |log_level|
    options.log_level = log_level
  end

  opts.on('-q', '--queue-name [NAME]', String, "Set the name of the queue to work jobs from (default: the default queue)") do |queue_name|
    options.queue_name = queue_name
  end

  opts.on('-t', '--priority-threshold [PRIORITY]', Integer, "Experimental, never intended to be merged") do |priority_threshold|
    options.priority_threshold = priority_threshold
  end

  opts.on('--timeout [TIMEOUT]', Integer, "Set the amount of time (in seconds) to wait, after receiving SIGTERM/SIGINT, for a worker to finish before forcing it to stop") do |timeout|
    options.timeout = timeout
  end

  opts.on('--timeout-message [MESSAGE]', String, "Set the exception message that will be sent in the event of a worker timeout") do |timeout_message|
    options.timeout_message = timeout_message
  end

  opts.on('-v', '--version', "Show Que version") do
    require 'que'
    $stdout.puts "Que version #{Que::Version}"
    exit 0
  end

  opts.on('-h', '--help', "Show help text") do
    $stdout.puts opts
    exit 0
  end
end.parse!(ARGV)

if ARGV.length.zero?
  $stdout.puts <<~OUTPUT
  You didn't include any Ruby files to require!
  Que needs to be able to load your application before it can process jobs.
  (Hint: If you're using Rails, try `que ./config/environment.rb`)
  (Or use `que -h` for a list of options)
  OUTPUT
  exit 1
end

ARGV.each do |file|
  begin
    require file
  rescue LoadError
    $stdout.puts "Could not load file '#{file}'"
  end
end

Que.logger ||= Logger.new(STDOUT)

begin
  if log_level = (options.log_level || ENV['QUE_LOG_LEVEL'])
    Que.logger.level = Logger.const_get(log_level.upcase)
  end
rescue NameError
  $stdout.puts "Bad logging level: #{log_level}"
  exit 1
end

queue_name          = options.queue_name         || ENV['QUE_QUEUE'] || Que::Worker::DEFAULT_QUEUE
wake_interval       = options.wake_interval      || ENV['QUE_WAKE_INTERVAL']&.to_f
metrics_labels      = options.metrics_labels     || {}
cursor_expiry       = options.cursor_expiry      || 0
priority_threshold  = options.priority_threshold || ENV['QUE_PRIORITY_THRESHOLD'].to_i
timeout             = options.timeout
timeout_message     = options.timeout_message    || ""

Que.logger.info(msg: 'Starting worker', event: 'que.worker.start')

worker = Que::Worker.new(
  queue: queue_name,
  wake_interval: wake_interval,
  metrics_labels: metrics_labels,
  priority_threshold: priority_threshold,
  lock_cursor_expiry: cursor_expiry
)

Thread.new { worker.metrics.expose(port: options.metrics_port) } if options.metrics_port

stop = false
%w[INT TERM].each { |signal| trap(signal) { stop = true } }

worker_thread = Thread.new { worker.work_loop }

sleep 0.1 until stop

Que.logger.info(msg: 'Waiting for worker to finish', event: 'que.worker.finish_wait')

worker.stop!

if timeout
  timeout.seconds.downto(0) do
    break unless worker_thread.alive?
    sleep 1
  end

  if worker_thread.alive?
    Que.logger.info(msg: 'Worker still running - forcing it to stop', event: 'que.worker.finish_force')
    worker_thread.raise(QueJobTimeoutError, timeout_message)
    worker_thread.join
  end
end

Que.logger.info(msg: 'Worker finished, exiting', event: 'que.worker.finish')
